# 1 "main.cpp"
# 1 "/home/colin/Development/OSdevelopment/Kernel/Kernel/temp//"
# 1 "<command-line>"
# 1 "main.cpp"
# 1 "debug.h" 1





void InitDebug(void);

void kcls(void);
void kprintf(const char *format, ...);
void test(char c);
# 2 "main.cpp" 2
# 1 "multiboot.h" 1
# 49 "multiboot.h"
typedef struct multiboot_header
{
  unsigned long magic;
  unsigned long flags;
  unsigned long checksum;
  unsigned long header_addr;
  unsigned long load_addr;
  unsigned long load_end_addr;
  unsigned long bss_end_addr;
  unsigned long entry_addr;
} multiboot_header_t;


typedef struct aout_symbol_table
{
  unsigned long tabsize;
  unsigned long strsize;
  unsigned long addr;
  unsigned long reserved;
} aout_symbol_table_t;


typedef struct elf_section_header_table
{
  unsigned long num;
  unsigned long size;
  unsigned long addr;
  unsigned long shndx;
} elf_section_header_table_t;


typedef struct multiboot_info
{
  unsigned long flags;
  unsigned long mem_lower;
  unsigned long mem_upper;
  unsigned long boot_device;
  unsigned long cmdline;
  unsigned long mods_count;
  unsigned long mods_addr;
  union
  {
    aout_symbol_table_t aout_sym;
    elf_section_header_table_t elf_sec;
  } u;
  unsigned long mmap_length;
  unsigned long mmap_addr;
} multiboot_info_t;


typedef struct module
{
  unsigned long mod_start;
  unsigned long mod_end;
  unsigned long string;
  unsigned long reserved;
} module_t;



typedef struct memory_map
{
  unsigned long size;
  unsigned long base_addr_low;
  unsigned long base_addr_high;
  unsigned long length_low;
  unsigned long length_high;
  unsigned long type;
} memory_map_t;
# 3 "main.cpp" 2
# 1 "mem_physical.h" 1



# 1 "runtime.h" 1







typedef unsigned int size_t;

typedef unsigned char UInt8;
typedef unsigned short UInt16;
typedef unsigned int UInt32;
# 5 "mem_physical.h" 2

typedef void* PhysicalPointer;
typedef unsigned long PhysicalLength;
typedef unsigned long PageCount;

class CPhysicalMemory
{
public:

 static const PhysicalPointer Minimum;
 static const PhysicalPointer Maximum;
 static const PhysicalPointer Invalid;


 static void Init(void);
 static void AddChunk(PhysicalPointer address, PhysicalLength length);
 static void AddReserved(PhysicalPointer address, PhysicalLength length);
 static PageCount TotalPages(void);
 static PageCount TotalUsed(void);
 static PhysicalLength PageToMemory(PageCount count);


 static PhysicalPointer AllocateContiguousPages(PageCount count = 1, PhysicalPointer min = Minimum, PhysicalPointer max = Maximum);
 static void ReleasePages(PhysicalPointer address, PageCount count = 1);
};
# 4 "main.cpp" 2
# 1 "tools.h" 1







# 1 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.1/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 102 "/usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.1/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 9 "tools.h" 2


class CStringPrint
{
public:
 CStringPrint();
 virtual ~CStringPrint();

 void Print(const char *format, ...);
 void PrintList(const char *format, va_list &params);

 static bool IsDigit(char c);
 static int LengthOf(const char *s);

protected:
 virtual void PrintOut(const char *data, int length) = 0;

private:
 int ParseFormat(va_list &params, const char *format);
};



static __inline__ void outb(unsigned short port, unsigned char val)
{
   asm volatile("outb %0,%1"::"a"(val), "Nd" (port));
}

static __inline__ void outw(unsigned short port, unsigned short val)
{
   asm volatile("outw %0,%1"::"a"(val), "Nd" (port));
}

static __inline__ void outl(unsigned short port, unsigned int val)
{
   asm volatile("outl %0,%1"::"a"(val), "Nd" (port));
}

static __inline__ unsigned char inb(unsigned short port)
{
   unsigned char ret;
   asm volatile ("inb %1,%0":"=a"(ret):"Nd"(port));
   return ret;
}

static __inline__ unsigned short inw(unsigned short port)
{
   unsigned short ret;
   asm volatile ("inw %1,%0":"=a"(ret):"Nd"(port));
   return ret;
}

static __inline__ unsigned int inl(unsigned short port)
{
   unsigned int ret;
   asm volatile ("inl %1,%0":"=a"(ret):"Nd"(port));
   return ret;
}
# 75 "tools.h"
static __inline__ void io_wait(void)
{
   asm volatile("outb %%al, $0x80" : : "a"(0));


}
# 5 "main.cpp" 2
# 1 "mem_logical.h" 1






typedef enum {
    pmApplication,
    pmKernel,
} MAP_TYPE;

typedef enum {
    fmWritable = 1,
    fmUser = 2,
    fmPageData = 4,
} MAP_FLAGS;

typedef struct {
    union {
        struct {
            UInt32 Present : 1;
            UInt32 Writable : 1;
            UInt32 User : 1;
            UInt32 WriteThrough : 1;
            UInt32 CacheDisable : 1;
            UInt32 Accessed : 1;
            UInt32 Available : 1;
            UInt32 PageSize : 1;
            UInt32 Global : 1;
            UInt32 UserData : 3;
            UInt32 Frame : 20;
        };
        UInt32 RawValue;
    };
} SPageDirectory;

typedef struct {
    union {
        struct {
            UInt32 Present : 1;
            UInt32 Writable : 1;
            UInt32 User : 1;
            UInt32 WriteThough : 1;
            UInt32 CacheDisable : 1;
            UInt32 Accessed : 1;
            UInt32 Dirty : 1;
            UInt32 PatIndex : 1;
            UInt32 Global : 1;
            UInt32 UserData : 3;
            UInt32 Frame : 20;
        };
        UInt32 RawValue;
    };
} SPage;

typedef struct {
    SPage pages[1024];
} SPageTable;

class SPageDirectoryInfo {
public:


    SPageTable *tables[1024];
    SPageDirectory *tablesPhysical;
    PhysicalPointer directoryPhysical;

    void InitKernel(void);

    void Init(void);
    void Release(void);
    void Select(void);

    void* Map( int permissions, MAP_TYPE location, PhysicalPointer physical, size_t count = 1);
    void Map( int permissions, void *location, PhysicalPointer physical);
    void Unmap(void *logical);
    PhysicalPointer Address(void *logical);

private:
    void Unmap(void *logical, bool mapPage);
    void CopyKernel(void);

    int revision;
};

extern SPageDirectoryInfo rootAddressSpace;
extern SPageDirectoryInfo *currentAddressSpace;
# 6 "main.cpp" 2

extern UInt32 kern_start, kern_end;

extern UInt32 virt, phys;

static inline void* FixAddress(void *address)
{
    return ((char*)address) + (UInt32)&virt - (UInt32)&phys;
}
extern UInt32 stack;
extern "C" int k_main(multiboot_info_t* mbd, unsigned int magic)
{
 memory_map_t *map;

 test('A');
 kprintf("Munro Systems\nCosmOS 1.0\nCopyright (C) 2008-2013 Colin Munro\n\n");
 if (magic != 0x2BADB002)
 {
  kprintf("Multiboot: magic number incorrect\n");
  return -1;
 }


 CPhysicalMemory::Init();
    rootAddressSpace.InitKernel();


 mbd = (multiboot_info_t*)FixAddress(mbd);

 kprintf("Multiboot: %iKb low mem, %iKb high mem:\n", mbd->mem_lower, mbd->mem_upper);
 for (
  map = (memory_map_t*)FixAddress((void*)mbd->mmap_addr);
  map < (memory_map_t*)(((char*)FixAddress((void*)mbd->mmap_addr)) + mbd->mmap_length);
  map = (memory_map_t*)(((char*)map) + map->size + sizeof(map->size)))
 {
  if (map->type == 0x01)
  {

   kprintf("\t0x%.8x: %i bytes\n", map->base_addr_low, map->length_low);
   CPhysicalMemory::AddChunk((PhysicalPointer)map->base_addr_low, map->length_low);
  }
 }
 kprintf("Reserving...\n");
 CPhysicalMemory::AddReserved((void*)&kern_start, ((char*)&kern_end) - ((char*)&kern_start));
    kprintf("Stack at 0x%.8x\n", &stack);

    InitDebug();


 kprintf("\nStarting!\n");
 test('Z');
 return 0;
}
