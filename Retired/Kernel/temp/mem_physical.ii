# 1 "mem_physical.cpp"
# 1 "/home/colin/Development/OSdevelopment/Kernel/Kernel/temp//"
# 1 "<command-line>"
# 1 "mem_physical.cpp"
# 1 "mem_physical.h" 1



# 1 "runtime.h" 1







typedef unsigned int size_t;

typedef unsigned char UInt8;
typedef unsigned short UInt16;
typedef unsigned int UInt32;
# 5 "mem_physical.h" 2

typedef void* PhysicalPointer;
typedef unsigned long PhysicalLength;
typedef unsigned long PageCount;

class CPhysicalMemory
{
public:

 static const PhysicalPointer Minimum;
 static const PhysicalPointer Maximum;
 static const PhysicalPointer Invalid;


 static void Init(void);
 static void AddChunk(PhysicalPointer address, PhysicalLength length);
 static void AddReserved(PhysicalPointer address, PhysicalLength length);
 static PageCount TotalPages(void);
 static PageCount TotalUsed(void);
 static PhysicalLength PageToMemory(PageCount count);


 static PhysicalPointer AllocateContiguousPages(PageCount count = 1, PhysicalPointer min = Minimum, PhysicalPointer max = Maximum);
 static void ReleasePages(PhysicalPointer address, PageCount count = 1);
};
# 2 "mem_physical.cpp" 2
# 1 "mem_logical.h" 1






typedef enum {
    pmApplication,
    pmKernel,
} MAP_TYPE;

typedef enum {
    fmWritable = 1,
    fmUser = 2,
    fmPageData = 4,
} MAP_FLAGS;

typedef struct {
    union {
        struct {
            UInt32 Present : 1;
            UInt32 Writable : 1;
            UInt32 User : 1;
            UInt32 WriteThrough : 1;
            UInt32 CacheDisable : 1;
            UInt32 Accessed : 1;
            UInt32 Available : 1;
            UInt32 PageSize : 1;
            UInt32 Global : 1;
            UInt32 UserData : 3;
            UInt32 Frame : 20;
        };
        UInt32 RawValue;
    };
} SPageDirectory;

typedef struct {
    union {
        struct {
            UInt32 Present : 1;
            UInt32 Writable : 1;
            UInt32 User : 1;
            UInt32 WriteThough : 1;
            UInt32 CacheDisable : 1;
            UInt32 Accessed : 1;
            UInt32 Dirty : 1;
            UInt32 PatIndex : 1;
            UInt32 Global : 1;
            UInt32 UserData : 3;
            UInt32 Frame : 20;
        };
        UInt32 RawValue;
    };
} SPage;

typedef struct {
    SPage pages[1024];
} SPageTable;

class SPageDirectoryInfo {
public:


    SPageTable *tables[1024];
    SPageDirectory *tablesPhysical;
    PhysicalPointer directoryPhysical;

    void InitKernel(void);

    void Init(void);
    void Release(void);
    void Select(void);

    void* Map( int permissions, MAP_TYPE location, PhysicalPointer physical, size_t count = 1);
    void Map( int permissions, void *location, PhysicalPointer physical);
    void Unmap(void *logical);
    PhysicalPointer Address(void *logical);

private:
    void Unmap(void *logical, bool mapPage);
    void CopyKernel(void);

    int revision;
};

extern SPageDirectoryInfo rootAddressSpace;
extern SPageDirectoryInfo *currentAddressSpace;
# 3 "mem_physical.cpp" 2

const PhysicalPointer CPhysicalMemory::Minimum = (PhysicalPointer)0x00000000;
const PhysicalPointer CPhysicalMemory::Maximum = (PhysicalPointer)0xFFFFFFFF;
const PhysicalPointer CPhysicalMemory::Invalid = (PhysicalPointer)0xFFFFFFFF;

typedef struct
{

 void *pageBase;
 unsigned int pageCount;
}
PAGE_ENTRY;

typedef struct PAGE_STACK
{
 PAGE_STACK *lastPage;
 PAGE_STACK *nextPage;
 unsigned int entryCount;
 unsigned int reserved;
 PAGE_ENTRY entries[510];
}
PAGE_STACK;

static PAGE_STACK basePage;
static PAGE_STACK *latestPage;
static unsigned int usedPages;

void CPhysicalMemory::Init(void)
{
 basePage.lastPage = 0L;
 basePage.nextPage = 0L;
 basePage.entryCount = 0;
 latestPage = &basePage;
 usedPages = 0;
}

static void GetNewPage(void)
{
 PhysicalPointer newPage = CPhysicalMemory::AllocateContiguousPages();
    PAGE_STACK *newObject = (PAGE_STACK*)currentAddressSpace->Map(fmWritable, pmKernel, newPage);
 newObject->lastPage = latestPage;
 newObject->nextPage = 0L;
 newObject->entryCount = 0;
 latestPage->nextPage = newObject;
 latestPage = newObject;
}

static void TidyPage(PAGE_STACK *page)
{
 if (page->entryCount != 0)
    {

        int x, y;

        for (x = y = 0; x < page->entryCount; x++)
        {
            if (page->entries[x].pageCount != 0)
                page->entries[y++] = page->entries[x];
        }
        page->entryCount = y;


        if (y != 0)
            return;
    }


 if (page == &basePage)
  return;


 if (page->nextPage != 0L)
  page->nextPage->lastPage = page->lastPage;
 if (page->lastPage != 0L)
  page->lastPage->nextPage = page->nextPage;
 if (latestPage == page)
  latestPage = page->lastPage;


 PhysicalPointer oldPage = currentAddressSpace->Address(page);
    currentAddressSpace->Unmap(page);
 CPhysicalMemory::ReleasePages(oldPage);
}

static void DropPages(void)
{
    PAGE_STACK *current, *next;


    for (current = &basePage; current != 0L; current = next)
    {
        next = current->nextPage;
        TidyPage(current);
    }
}

void CPhysicalMemory::AddChunk(PhysicalPointer address, PhysicalLength length)
{
 PAGE_STACK *current;
 int index, pageCount;
 unsigned char *newStart, *newEnd;
 unsigned char *curStart, *curEnd;

 newStart = (unsigned char*)address;
 newEnd = newStart + length;
 pageCount = length >> 12;
 for (current = &basePage; current != 0L; current = current->nextPage)
 {
  for (index = current->entryCount; index != 0;)
  {
   index--;
   curStart = (unsigned char*)current->entries[index].pageBase;
   curEnd = curStart + (current->entries[index].pageCount << 12);
   if (newEnd == curStart)
   {

    current->entries[index].pageBase = (void*)address;
    current->entries[index].pageCount += pageCount;
    return;
   }
   if (newStart == curEnd)
   {

    current->entries[index].pageCount += pageCount;
    return;
   }
  }
 }

 current = &basePage;
 while (true)
 {
  for (; current != 0L; current = current->nextPage)
  {
   if (current->entryCount < 510)
   {
    int newEntry = current->entryCount++;
    current->entries[newEntry].pageBase = (void*)address;
    current->entries[newEntry].pageCount = pageCount;
    return;
   }
  }
  GetNewPage();
  current = latestPage;
 }
}

void CPhysicalMemory::AddReserved(PhysicalPointer address, PhysicalLength length)
{

    int pageCount = (length + 0x00000FFF) & 0xFFFFF000;
    char* reserveLower = (char*)address;
    char* reserveUpper = reserveLower + (pageCount << 12);
    for (PAGE_STACK *current = &basePage; current != 0L; current = current->nextPage)
    {
        for (int i = 0; i < current->entryCount; i++)
        {
            PAGE_ENTRY *entry = current->entries + i;
            char* entryLower = (char*)entry->pageBase;
            char* entryUpper = entryLower + (entry->pageCount << 12);

            if (reserveLower <= entryLower)
            {
                if (reserveUpper < entryLower)
                {

                }
                else if (reserveUpper > entryUpper)
                {

                    entry->pageCount = 0;
                }
                else
                {

                    entry->pageBase = reserveUpper;
                    entry->pageCount -= (reserveUpper - entryLower) >> 12;
                }
            }
            else
            {
                if (reserveLower > entryUpper)
                {

                }
                else if (reserveUpper < entryUpper)
                {

                    entry->pageCount = (entryUpper - reserveLower) >> 12;
                    AddChunk(reserveUpper, entryUpper - reserveUpper);
                }
                else
                {

                    entry->pageCount = (entryUpper - reserveLower) >> 12;
                }

            }
        }
    }
    DropPages();
}

PageCount CPhysicalMemory::TotalPages(void)
{
 PageCount count;

 count = 0;
 for (PAGE_STACK *current = &basePage; current != 0L; current = current->nextPage)
 {
  for (int i = 0; i < current->entryCount; i++)
  {
   count += current->entries[i].pageCount;
  }
 }
 return count;
}

PageCount CPhysicalMemory::TotalUsed(void)
{
 return usedPages;
}

PhysicalLength CPhysicalMemory::PageToMemory(PageCount count)
{
 return count << 12;
}

PhysicalPointer CPhysicalMemory::AllocateContiguousPages(PageCount count, PhysicalPointer min, PhysicalPointer max)
{
 PAGE_STACK *current;
 int index;

 for (current = latestPage; current != 0L; current = current->lastPage)
 {
  for (index = current->entryCount; index != 0;)
  {
   index--;
   if ((current->entries[index].pageCount >= count)
            && ((current->entries[index].pageBase >= min) && ((((char*)current->entries[index].pageBase) + current->entries[index].pageCount) < max)))
   {
    PhysicalPointer result;

    result = current->entries[index].pageBase;
    current->entries[index].pageBase = ((char*)current->entries[index].pageBase) + (count << 12);
    current->entries[index].pageCount -= count;
    if (current->entries[index].pageCount == 0)
     TidyPage(current);
    usedPages += count;
    return result;
   }
  }
 }
 return Invalid;
}

void CPhysicalMemory::ReleasePages(PhysicalPointer address, PageCount count)
{

 AddChunk(address, count << 12);
 usedPages -= count;
}
