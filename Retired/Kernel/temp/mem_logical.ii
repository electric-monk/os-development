# 1 "mem_logical.cpp"
# 1 "/home/colin/Development/OSdevelopment/Kernel/Kernel/temp//"
# 1 "<command-line>"
# 1 "mem_logical.cpp"
# 1 "mem_logical.h" 1



# 1 "mem_physical.h" 1



# 1 "runtime.h" 1







typedef unsigned int size_t;

typedef unsigned char UInt8;
typedef unsigned short UInt16;
typedef unsigned int UInt32;
# 5 "mem_physical.h" 2

typedef void* PhysicalPointer;
typedef unsigned long PhysicalLength;
typedef unsigned long PageCount;

class CPhysicalMemory
{
public:

 static const PhysicalPointer Minimum;
 static const PhysicalPointer Maximum;
 static const PhysicalPointer Invalid;


 static void Init(void);
 static void AddChunk(PhysicalPointer address, PhysicalLength length);
 static void AddReserved(PhysicalPointer address, PhysicalLength length);
 static PageCount TotalPages(void);
 static PageCount TotalUsed(void);
 static PhysicalLength PageToMemory(PageCount count);


 static PhysicalPointer AllocateContiguousPages(PageCount count = 1, PhysicalPointer min = Minimum, PhysicalPointer max = Maximum);
 static void ReleasePages(PhysicalPointer address, PageCount count = 1);
};
# 5 "mem_logical.h" 2


typedef enum {
    pmApplication,
    pmKernel,
} MAP_TYPE;

typedef enum {
    fmWritable = 1,
    fmUser = 2,
    fmPageData = 4,
} MAP_FLAGS;

typedef struct {
    union {
        struct {
            UInt32 Present : 1;
            UInt32 Writable : 1;
            UInt32 User : 1;
            UInt32 WriteThrough : 1;
            UInt32 CacheDisable : 1;
            UInt32 Accessed : 1;
            UInt32 Available : 1;
            UInt32 PageSize : 1;
            UInt32 Global : 1;
            UInt32 UserData : 3;
            UInt32 Frame : 20;
        };
        UInt32 RawValue;
    };
} SPageDirectory;

typedef struct {
    union {
        struct {
            UInt32 Present : 1;
            UInt32 Writable : 1;
            UInt32 User : 1;
            UInt32 WriteThough : 1;
            UInt32 CacheDisable : 1;
            UInt32 Accessed : 1;
            UInt32 Dirty : 1;
            UInt32 PatIndex : 1;
            UInt32 Global : 1;
            UInt32 UserData : 3;
            UInt32 Frame : 20;
        };
        UInt32 RawValue;
    };
} SPage;

typedef struct {
    SPage pages[1024];
} SPageTable;

class SPageDirectoryInfo {
public:


    SPageTable *tables[1024];
    SPageDirectory *tablesPhysical;
    PhysicalPointer directoryPhysical;

    void InitKernel(void);

    void Init(void);
    void Release(void);
    void Select(void);

    void* Map( int permissions, MAP_TYPE location, PhysicalPointer physical, size_t count = 1);
    void Map( int permissions, void *location, PhysicalPointer physical);
    void Unmap(void *logical);
    PhysicalPointer Address(void *logical);

private:
    void Unmap(void *logical, bool mapPage);
    void CopyKernel(void);

    int revision;
};

extern SPageDirectoryInfo rootAddressSpace;
extern SPageDirectoryInfo *currentAddressSpace;
# 2 "mem_logical.cpp" 2
# 1 "debug.h" 1





void InitDebug(void);

void kcls(void);
void kprintf(const char *format, ...);
void test(char c);
# 3 "mem_logical.cpp" 2

SPageDirectoryInfo rootAddressSpace;
SPageDirectoryInfo *currentAddressSpace;


extern SPageDirectory BootPageDirectory;
extern SPageTable PageMapBootstrap;


extern UInt32 virt;
extern UInt32 phys;

int availableMappingPages;

static inline void InvalidateTLB(void *m)
{
    asm volatile("invlpg %0"
                 :
                 : "m"(*reinterpret_cast<char*>(m))
                 : "memory"
                 );
}

void SPageDirectoryInfo::InitKernel(void)
{
    kprintf("Kernel logical 0x%.8x, physical 0x%.8x\n", (int)&phys, (int)&virt);

    currentAddressSpace = this;
    tablesPhysical = &BootPageDirectory;
    directoryPhysical = (PhysicalPointer)(reinterpret_cast<UInt32>(&phys) + ((unsigned int)&BootPageDirectory) - reinterpret_cast<UInt32>(&virt));

    revision = 1;


    tablesPhysical[0].Present = 0;
    InvalidateTLB(0x00000000);


    for (int i = 0; i < 1024; i++)
    {
        if (tablesPhysical[i].Present)
        {

            if (tablesPhysical[i].PageSize)
            {

                tables[i] = (SPageTable*)0xFFFFFFFF;
                kprintf("4MB page found at %i\n", i);
            }
            else
            {

            }

        }
        else
        {
            tables[i] = 0L;
        }
    }


    PhysicalPointer bootstrapPhysical = (PhysicalPointer)(reinterpret_cast<UInt32>(&phys) + reinterpret_cast<UInt32>(&PageMapBootstrap) - reinterpret_cast<UInt32>(&virt));
    availableMappingPages = 1023;
    for (int i = 0; i < 1024; i++)
        PageMapBootstrap.pages[i].RawValue = 0x00000000;
    PageMapBootstrap.pages[1023].Frame = ((unsigned int)bootstrapPhysical & 0xFFFFF000) >> 12;
    PageMapBootstrap.pages[1023].Writable = 1;
    PageMapBootstrap.pages[1023].Present = 1;

    tablesPhysical[1023].Frame = ((unsigned int)bootstrapPhysical & 0xFFFFF000) >> 12;
    tablesPhysical[1023].Available = 1;
    tablesPhysical[1023].Writable = 1;
    tablesPhysical[1023].Present = 1;
    tables[1023] = (SPageTable*)0xFFFFF000;
    InvalidateTLB(tables[1023]);
}

void SPageDirectoryInfo::Init(void)
{

    directoryPhysical = CPhysicalMemory::AllocateContiguousPages();
    tablesPhysical = (SPageDirectory*)Map(fmWritable, pmKernel, directoryPhysical);


    for (int i = 0; i < 1024; i++)
    {
        tables[i] = 0L;
        tablesPhysical[i].RawValue = 0x00000000;
    }


    revision = 0;
}

void SPageDirectoryInfo::Release(void)
{

    for (int i = 0; i < (((UInt32)&phys) >> 22); i++)
    {
        if (!tablesPhysical[i].Present)
            continue;

        if (tablesPhysical[i].PageSize)
        {

            continue;
        }

        for (int j = 0; j < 1024; j++)
        {
            if (!tables[i]->pages[j].Present)
                continue;
            CPhysicalMemory::ReleasePages((PhysicalPointer)(tables[i]->pages[j].Frame << 12));
        }
    }


    Unmap(tablesPhysical);
    CPhysicalMemory::ReleasePages(directoryPhysical);
}

void SPageDirectoryInfo::Select(void)
{
    if (&rootAddressSpace != this)
    {
        if (revision != rootAddressSpace.revision)
        {
            CopyKernel();
        }
    }
    asm volatile("mov %0, %%cr3"::"r" (directoryPhysical));
    currentAddressSpace = this;
}

void* SPageDirectoryInfo::Map(int permissions, MAP_TYPE location, PhysicalPointer physical, size_t count)
{
    kprintf("SPageDirectoryInfo::Map(%.4x, %.2x, 0x%.8x, %i)\n", permissions, location, (int)physical, (int)count);

    UInt32 min, max;
    bool searchReverse;

    void *newLocation, *currentLocation;
    size_t foundLength;

    if ((location == pmKernel) && (this != &rootAddressSpace))
    {
        newLocation = rootAddressSpace.Map(permissions, location, physical, count);
        CopyKernel();
        return newLocation;
    }


    searchReverse = false;
    switch (location)
    {
        case pmApplication:
            if (permissions & fmPageData)
                return 0L;
            min = 0x00001000;
            max = ((UInt32)&virt) - 0x1000;
            break;
        case pmKernel:
            if (permissions & fmPageData)
            {
                if (count != 1)
                    return 0L;
                searchReverse = true;

            }
            min = (UInt32)&virt;
            max = 0xFFFFF000;
            break;
        default:
            return 0L;
    }



    kprintf("Searching %s between 0x%.8x and 0x%.8x (kernel base 0x%.8x)\n",
            searchReverse ? "down" : "up",
            (void*)min, (void*)max, (void*)&virt);
    newLocation = 0L;
    currentLocation = (void*)(searchReverse ? max : min);
    foundLength = 0;
    while (foundLength < count)
    {
        if ((currentLocation < (void*)min) || (currentLocation > (void*)max))
            return 0L;

        PhysicalPointer ptr = Address(currentLocation);
        if (Address(currentLocation) == CPhysicalMemory::Invalid)
        {
            if (foundLength == 0)
                newLocation = currentLocation;
            foundLength++;
        }
        else
        {
            foundLength = 0;
        }

        if (searchReverse)
            currentLocation = (void*)(((UInt32)currentLocation) - 0x1000);
        else
            currentLocation = (void*)(((UInt32)currentLocation) + 0x1000);
    }
    if (newLocation == 0L)
        return 0L;

    if ((permissions & fmPageData) && (availableMappingPages == 1))
    {
        int pageDirEntry;


        for (pageDirEntry = 1023; pageDirEntry >= 0; pageDirEntry--)
        {
            if (!tablesPhysical[pageDirEntry].Present)
                break;
        }
        if (pageDirEntry < 0)
            return 0L;


        PhysicalPointer newPage = CPhysicalMemory::AllocateContiguousPages();
        Map(fmWritable, newLocation, newPage);
        SPageTable *newTable = (SPageTable*)newLocation;


        for (int i = 0; i < 1024; i++)
            newTable->pages[i].RawValue = 0x00000000;


        tablesPhysical[pageDirEntry].Frame = ((unsigned int)newPage & 0xFFFFF000) >> 12;
        tablesPhysical[pageDirEntry].Writable = 1;
        tablesPhysical[pageDirEntry].Available = 1;
        tablesPhysical[pageDirEntry].Present = 1;
        tables[pageDirEntry] = newTable;


        availableMappingPages += 1024 - 1;


        newLocation = (void*)((pageDirEntry << 22) | (0xFFF << 12));
    }


    for (foundLength = 0, currentLocation = newLocation;
         foundLength < count;
         foundLength++, currentLocation = ((unsigned char*)currentLocation) + 0x1000, physical = ((unsigned char*)physical) + 0x1000)
        Map(permissions, currentLocation, physical);


    if (this == &rootAddressSpace)
    {
        revision++;
        if (revision == 0)
            revision = 1;
    }


    kprintf("Generated new mapping at 0x%.8x\n", newLocation);
    return newLocation;
}

void SPageDirectoryInfo::Map(int permissions, void *location, PhysicalPointer physical)
{
    kprintf("SPageDirectoryInfo::Map(%.4x, 0x%.8x, 0x%.8x)\n", permissions, (int)location, (int)physical);
    test('0');

    unsigned int dirEntry = (((unsigned int)location) >> 22) & 0x3FF;
    unsigned int pagEntry = (((unsigned int)location) >> 12) & 0x3FF;
    unsigned int pagOffset = ((unsigned int)location) & 0xFFF;


    if (!tablesPhysical[dirEntry].Present)
    {
        test('1');
        PhysicalPointer newPage = CPhysicalMemory::AllocateContiguousPages();
        test('2');
        tables[dirEntry] = (SPageTable*)Map(fmPageData | fmWritable, pmKernel, newPage);

        test('3');

        for (int i = 0; i < 1024; i++) {
            tables[dirEntry]->pages[i].RawValue = 0x00000000;
        }

        test('4');

        SPageDirectory newDirectoryEntry;
        newDirectoryEntry.RawValue = 0x00000000;
        newDirectoryEntry.Frame = ((unsigned int)(((UInt32)newPage) & 0xFFFFF000)) >> 12;
        newDirectoryEntry.Present = 1;
        newDirectoryEntry.Writable = 1;
        newDirectoryEntry.User = 0;
        newDirectoryEntry.WriteThrough = 0;
        newDirectoryEntry.CacheDisable = 0;
        newDirectoryEntry.Accessed = 0;
        newDirectoryEntry.Available = 1;
        newDirectoryEntry.PageSize = 0;
        newDirectoryEntry.Global = 0;
        tablesPhysical[dirEntry] = newDirectoryEntry;
    }

    test('5');
    SPage newPageInfo;
    newPageInfo.RawValue = 0x00000000;
    newPageInfo.Present = 1;
    if (permissions & fmWritable)
        newPageInfo.Writable = 1;
    if (permissions & fmUser)
        newPageInfo.User = 1;
    newPageInfo.Frame = ((unsigned int)(((UInt32)physical) & 0xFFFFF000)) >> 12;


    test('6');
    tables[dirEntry]->pages[pagEntry] = newPageInfo;
    test('7');
    InvalidateTLB(location);
    kprintf("0x%.8x mapped\n", location);
}

void SPageDirectoryInfo::Unmap(void *logical)
{
    Unmap(logical, false);
}

void SPageDirectoryInfo::Unmap(void *logical, bool mapPage)
{

    if (logical == &PageMapBootstrap)
        return;


    unsigned int dirEntry = (((unsigned int)logical) >> 22) & 0x3FF;
    unsigned int pagEntry = (((unsigned int)logical) >> 12) & 0x3FF;
    unsigned int pagOffset = ((unsigned int)logical) & 0xFFF;


    if (!tablesPhysical[dirEntry].Present)
        return;
    if (tables[dirEntry] == (void*)0xFFFFFFFF)
        return;
    if (!tables[dirEntry]->pages[pagEntry].Present)
        return;


    tables[dirEntry]->pages[pagEntry].Present = 0;
    InvalidateTLB(logical);
    if (mapPage)
        availableMappingPages++;


    for (int i = 0; i < 1024; i++)
    {
        if (tables[dirEntry]->pages[i].Present)
            return;
    }


    tablesPhysical[dirEntry].Present = 0;
    Unmap(tables[dirEntry], true);
    tables[dirEntry] = 0L;
    CPhysicalMemory::ReleasePages((PhysicalPointer)(tablesPhysical[dirEntry].Frame << 12));
    if (mapPage)
        availableMappingPages += -1024 + 1;
}

PhysicalPointer SPageDirectoryInfo::Address(void *logical)
{


    unsigned int directoryIndex = (((unsigned int)logical) & 0xFFC00000) >> 22;
    if (!tablesPhysical[directoryIndex].Present)
        return CPhysicalMemory::Invalid;



    if (tablesPhysical[directoryIndex].PageSize)
        return (PhysicalPointer)(((tablesPhysical[directoryIndex].Frame << 12) & 0xFFC00000) | (((unsigned int)logical) & 0x003FFFFF));



    SPageTable *table = tables[directoryIndex];
    unsigned int tableIndex = (((unsigned int)logical) & 0x003FF000) >> 12;
    if (!table->pages[tableIndex].Present)
        return CPhysicalMemory::Invalid;

    return (PhysicalPointer)((table->pages[tableIndex].Frame << 12) | (((unsigned int)logical) & 0x00000FFF));
}

void SPageDirectoryInfo::CopyKernel(void)
{
    for (int i = (((UInt32)&virt) >> 22); i < 1024; i++)
    {
        tables[i] = rootAddressSpace.tables[i];
        tablesPhysical[i] = rootAddressSpace.tablesPhysical[i];
    }
    revision = rootAddressSpace.revision;
}
